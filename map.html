<script>
    var map = null;
    var markers = []; 
    var polylines = [];
    
    // [변경] 단일 인덱스 -> 다중 인덱스 배열 관리
    var selectedIndices = []; 

    var dragStartPos = null;

    function initMap() {
        map = new naver.maps.Map('map', {
            center: new naver.maps.LatLng(37.057202, 127.048285),
            zoom: 12
        });
    }

    function renderAllMarkers(dataList) {
        clearAllMarkers();
        for (var i = 0; i < dataList.length; i++) {
            var data = dataList[i];
            _createMarkerInternal(data.lat, data.lng, data.index, data.tooltip);
        }
        drawConnectors();
        updateMarkerVisuals(); 
    }

    // [신규] C#에서 선택된 인덱스 리스트를 받아옴 (예: [0, 2, 5])
    function setMarkerSelectionList(indices) {
        selectedIndices = indices; // 배열 교체
        updateMarkerVisuals();
    }

    // [변경] 마커 색상 업데이트 (배열 체크 방식)
    function updateMarkerVisuals() {
        var total = markers.length;

        for (var i = 0; i < total; i++) {
            var marker = markers[i];
            var iconContent = marker.getIcon().content;
            
            var newClass = "bg-red"; // 기본

            // [변경] 배열에 포함되어 있는지 확인 (indexOf > -1 or includes)
            if (selectedIndices.indexOf(i) !== -1) {
                newClass = "bg-blue";
            } else if (i === 0) {
                newClass = "bg-yellow";
            } else if (i === total - 1) {
                newClass = "bg-green";
            }

            var newHtml = iconContent.replace(/class="marker-pin [^"]*"/, 'class="marker-pin ' + newClass + '"');
            
            marker.setIcon({
                content: newHtml,
                size: new naver.maps.Size(30, 30),
                anchor: new naver.maps.Point(15, 15)
            });

            // 선택된 녀석들은 z-index 높임
            marker.setZIndex(selectedIndices.indexOf(i) !== -1 ? 10000 : 100);
        }
    }

    function _createMarkerInternal(lat, lng, gridIndex, tooltip) {
        var displayNum = gridIndex + 1;
        var contentHtml = '<div class="marker-pin bg-red" title="' + tooltip + '">' + displayNum + '</div>';

        var marker = new naver.maps.Marker({
            position: new naver.maps.LatLng(lat, lng),
            map: map,
            draggable: true,
            icon: {
                content: contentHtml,
                size: new naver.maps.Size(30, 30),
                anchor: new naver.maps.Point(15, 15)
            }
        });

        marker.set('gridIndex', gridIndex);

        // [핵심 변경] 클릭 시 Shift 키 상태 감지하여 전송
        naver.maps.Event.addListener(marker, 'click', function(e) {
            // 네이버 지도 API 이벤트 객체에서 DOM 이벤트 추출
            var domEvent = e.domEvent || e.pointerEvent; 
            var isShift = domEvent ? domEvent.shiftKey : false;

            if (window.chrome && window.chrome.webview) {
                // 형식: markerClick:인덱스:쉬프트눌림여부(true/false)
                window.chrome.webview.postMessage("markerClick:" + gridIndex + ":" + isShift);
            }
        });

        // 드래그 시작/종료 로직은 기존 유지
        naver.maps.Event.addListener(marker, 'dragstart', function(e) {
            dragStartPos = marker.getPosition();
            marker.setZIndex(10000);
        });

        naver.maps.Event.addListener(marker, 'dragend', function(e) {
            var droppedCoord = e.coord;
            var fromIndex = marker.get('gridIndex');
            var targetIndex = -1;
            var projection = map.getProjection();
            var droppedPoint = projection.fromCoordToOffset(droppedCoord);

            for (var i = 0; i < markers.length; i++) {
                var otherMarker = markers[i];
                var otherIndex = otherMarker.get('gridIndex');
                if (fromIndex === otherIndex) continue;

                var otherPoint = projection.fromCoordToOffset(otherMarker.getPosition());
                var dist = Math.sqrt(Math.pow(droppedPoint.x - otherPoint.x, 2) + Math.pow(droppedPoint.y - otherPoint.y, 2));

                if (dist < 40) {
                    targetIndex = otherIndex;
                    break;
                }
            }

            marker.setPosition(dragStartPos); 
            
            if (targetIndex !== -1) {
                if (window.chrome && window.chrome.webview) {
                    window.chrome.webview.postMessage("reorder:" + fromIndex + ":" + targetIndex);
                }
            }
        });

        markers.push(marker);
    }

    // ... drawConnectors, clearAllMarkers 등 나머지 함수는 그대로 유지 ...
    function drawConnectors() {
        for (var i = 0; i < polylines.length; i++) polylines[i].setMap(null);
        polylines = [];
        if (markers.length < 2) return;
        for (var i = 0; i < markers.length - 1; i++) {
            var start = markers[i].getPosition();
            var end = markers[i + 1].getPosition();
            var polyline = new naver.maps.Polyline({
                map: map, path: [start, end], strokeColor: '#FF0000', strokeWeight: 4, strokeOpacity: 0.8,
                endIcon: naver.maps.PointingIcon.OPEN_ARROW, endIconSize: 20
            });
            polylines.push(polyline);
        }
    }

    function clearAllMarkers() {
        for (var i = 0; i < markers.length; i++) markers[i].setMap(null);
        markers = [];
        for (var j = 0; j < polylines.length; j++) polylines[j].setMap(null);
        polylines = [];
        selectedIndices = []; // 초기화 시 선택 목록도 비움
    }

    initMap();
</script>
